<!DOCTYPE HTML>
<html lang="en">
<head>
    <title>Raphael Workshop</title>
    <style>
        @font-face {
        	font-family: 'DadhandRegular';
        	src: url('../lib/dadhand-webfont.eot');
        	src: local('â˜º'), url('../lib/dadhand-webfont.woff') format('woff'), url('../lib/dadhand-webfont.ttf') format('truetype'), url('../lib/dadhand-webfont.svg#webfontiNDkHeiT') format('svg');
        	font-weight: normal;
        	font-style: normal;
        }        
        .wftext{
            fill: #FFFFFF;
			font-weight: normal;
			font-style: normal;
			line-height:normal;
			font-size: 18pt;
            font-family: 'DadhandRegular', Georgia, "New Century Schoolbook", "Nimbus Roman No9 L", serif;
            font-size-adjust: 0.45;
        }
        .wfline{
            stroke: #FFFFFF;
            stoke-width: 2px;
        }
        .nobp .wfline{
            stroke: #333333;
        }
        .nobp .wftext{
            fill: #333333;
        }
    </style>
</head>
<body>
    <pre><code>
        sketch 500 500 true
        arrow 150  150 200 200
        arrow 150 90 180 65
        rect 70 90 70 50 Baz
        rect 210 180 60 90 Foo
        rect 190 40 80 50 Bar
        img 400 400 80 50
    </code><pre>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/raphael-min.js"></script>
    <script>
    Raphael.fn.line = function(x1,y1, x2,y2){
        var path = new Path()
            .moveto(x1, y1)
            .lineto(x2, y2);
        return this.path(path);
    };
    Raphael.fn.blueprint = function(spacing){
        var background = '#3459B3';
        var self = this;
        var lines = '#4B6DBC';
        if (spacing === undefined){
            spacing = 10;
        }
        this.rect(0,0,WIDTH,HEIGHT).attr('fill', background);
        var lineattrs = {stroke: lines, 'stroke-width': 0.5};
        $u.iterrange(0, WIDTH, spacing, function(x){
            self.line(x, 0, x, HEIGHT).attr(lineattrs);
        });
        $u.iterrange(0, HEIGHT, spacing, function(y){
            self.line(0, y, WIDTH, y).attr(lineattrs);
        });
    }
    jQuery.fn.extend({
        sketch: function(){
            this.each(function(){
                var self = $(this);
                var elem = this;
                var lines = $.trim(self.text()).split('\n');
                if (lines.length && /^sketch/.test(lines[0])){
                    var sketch;
                    $.each(lines, function(idx, line){
                        var words = $.trim(line).split(/\s+/);
                        var cmd = words[0];
                        switch(cmd){
                            case 'sketch':
                                self.text('');
                                var w = $u.integ(words[1]),
                                    h = $u.integ(words[2]),
                                    bp = words.length > 3 && words[3] === 'true';
                                sketch = new Sketch(elem, w, h, bp);
                                break;
                            case 'line':
                            case 'rect':
                            case 'arrow':
                            case 'img':
                                var args = $u.intarray(words.slice(1,5));
                                args.push(words.slice(5).join(' ')); // text for rect
                                sketch[cmd].apply(sketch, args);
                                break;
                            case 'text':
                                var x = parseInt(words[1], 10),
                                    y = parseInt(words[2], 10),
                                    text = words.slice(3).join(' ');
                                sketch.text(x,y,text);
                                break;
                        }
                        if (sketch){
                            sketch.draw();
                        }
                    });
                }
            });
        }
    });
    var WIDTH = 500,
        HEIGHT = 500,
        paper = Raphael($('.canvas')[0], WIDTH, HEIGHT);
    // Utility methods I usually need
    
    function Path(){
        this._path = [];
    }
    Path.prototype.moveto = function(x, y){
        this._path.push('M' + x + ' ' + y);
        return this;
    };
    Path.prototype.moveby = function(x, y){
        this._path.push('m' + x + ' ' + y);
        return this;
    };
    Path.prototype.lineto = function(x, y){
        this._path.push('L' + x + ' ' + y);
        return this;
    };
    Path.prototype.lineby = function(x, y){
        this._path.push('l' + x + ' ' + y);
        return this;
    };
    Path.prototype.closepath = function(){
        this._path.push('Z');
        return this;
    };
    Path.prototype.horizontalto = function(x){
        this._path.push('H' + x);
        return this;
    };
    Path.prototype.horizontalby = function(x){
        this._path.push('h' + x);
        return this;
    };
    Path.prototype.verticalto = function(y){
        this._path.push('V' + y);
        return this;
    };
    Path.prototype.verticalby = function(y){
        this._path.push('v', + y);
        return this;
    };
    Path.prototype.beziercurveto = function(cx1, cy1, cx2, cy2, x, y){
        this._path.push('C' + [cx1, cy1, cx2, cy2, x, y].map(function(p){return Math.round(p);}).join(' '));
        return this;
    };
    Path.prototype.beziercurveby = function(cx1, cy1, cx2, cy2, x, y){
        this._path.push('c' + [cx1, cy1, cx2, cy2, x, y].join(' '));
        return this;
    };
    // Can add smooth and quadratic beziers and elliptical arcs as needed
    Path.prototype.toString = function(){
        return this._path.join(' ');
    };
    Path.prototype.curve = function(vertArray, tightness){
    // Catmull-Rom curve, approximated with beziers
        if (vertArray.length > 3) {
            var b = [],
                curTightness = tightness || 0,
                s = 1 - curTightness;
            this.moveto(vertArray[1][0], vertArray[1][1]);
             /*
             * Matrix to convert from Catmull-Rom to cubic Bezier
             * where t = curTightness
             * |0         1          0         0       |
             * |(t-1)/6   1          (1-t)/6   0       |
             * |0         (1-t)/6    1         (t-1)/6 |
             * |0         0          0         0       |
             */
             for (var i = 1; (i+2) < vertArray.length; i++) {
                 b[0] = [vertArray[i][0], vertArray[i][1]];
                 b[1] = [vertArray[i][0] + (s * vertArray[i+1][0] - s * vertArray[i-1][0]) / 6,
                    vertArray[i][1] + (s * vertArray[i+1][1] - s * vertArray[i-1][1]) / 6];
                 b[2] = [vertArray[i+1][0] + (s * vertArray[i][0] - s * vertArray[i+2][0]) / 6,
                    vertArray[i+1][1] + (s * vertArray[i][1] - s * vertArray[i+2][1]) / 6];
                 b[3] = [vertArray[i+1][0], vertArray[i+1][1]];
                 this.beziercurveto(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
             }
             return this;
         }
     };
    
    function Sketch(elem, width,height,blueprint){
        this._paper = Raphael(elem, width, height);
        if(blueprint){
            this._paper.blueprint();
        }else{
            $(elem).addClass('nobp');
        }
        this._path = new Path();
    }
    Sketch.prototype.line = function(x1, y1, x2, y2){
        var random = $u.random;
        var overlines = $u.choice([1,1,1,1,1,1,1,2,2,2,3]);
        for (var i = 0; i < overlines; i++){
            this._path.curve([[ x1 + random(-2,2), y1 +random(-2,2)],
                      [ x1 + random(-2,2), y1 +random(-2,2)],
                      [ x1+(x2 -x1)/3 + random(-2,2), y1 + (y2-y1)/3 +random(-2,2)],
                      [ x1+2*(x2-x1)/3 + random(-2,2), y1+ 2*(y2-y1)/3 +random(-2,2)], 
                      [ x2 + random(-2,2), y2 +random(-2,2)],
                      [ x2 + random(-2,2), y2 +random(-2,2)]]);
        }
        return this;
    };
    Sketch.prototype.rect = function(x, y, w, h, text){
        this.line(x,y,x,y+h);
        this.line(x,y,x+w,y);
        this.line(x+w,y,x+w,y+h);
        this.line(x,y+h,x+w,y+h);
        if (text !== undefined){
            this.text(x+w/2,y+h/2,text);
        }
        return this;
    };
    Sketch.prototype.text = function(x, y, text){
        var t = this._paper.text(x,y,text).node;
        t.removeAttribute('style');
        t.removeAttribute('font');
        t.removeAttribute('fill');
        t.setAttribute('class', 'wftext');
        return this;
    };
    Sketch.prototype.arrow = function(x1,y1,x2,y2){
        var angle = Raphael.angle(x1,y1,x2,y2);
        var x3,y3,x4,y4;
        x3 = $u.dcos(angle + 45) * 10 + x2;
        y3 = $u.dsin(angle + 45) * 10 + y2;
        x4 = $u.dcos(angle - 45) * 10 + x2;
        y4 = $u.dsin(angle - 45) * 10 + y2;
        this.line(x1,y1,x2,y2);
        this.line(x2,y2,x3,y3);
        this.line(x2,y2,x4,y4);
        return this;
    };
    Sketch.prototype.img = function(x,y,w,h){
        this.rect(x,y,w,h);
        this.line(x,y,x+w,y+h);
        this.line(x+w,y,x,y+h);
    };
    Sketch.prototype.draw = function(){
        var n = this._paper.path(this._path).node;
        n.removeAttribute('stroke');
        n.setAttribute('class', 'wfline');
        return this;
    };



    var $u = {
        removeItem: function(list, item){
            list.splice(list.indexOf(item), 1);
        },
        dcos: function(degrees){
            return Math.cos(Raphael.rad(degrees));
        },
        dsin: function(degrees){
            return Math.sin(Raphael.rad(degrees));
        },
        random: function(a,b){
            // 'Returns an integer between a and b, inclusive';
            // 'If b is not specified, returns an integer between 0 and a';
            if (b === undefined){
                b = a;
                a = 0;
            }
            return Math.floor(Math.random() * (b-a + 1)) + a;
        },
        choice: function(list){
            // This is an exclusive, or mutating choice that
            // picks a random item from a list and removes that
            // item before returning it
            var idx = $u.random(0, list.length - 1);
            var item = list[idx];
            list.splice(idx, 1); // remove item from list
            return item;
        },
        range: function(start, stop, step){
            // similar to Python's range function
            // should be extended to handle negative steps
            if (stop === undefined){
                stop = start;
                start = 0;
            }
            if (step === undefined){
                step = 1;
            }
            var r = [], i;
            for(i = start; i < stop; i += step){
                r.push(i);
            }
            return r;
        },
        iterrange: function(start, stop, step, func){
            var r = $u.range(start, stop, step);
            for (var i in r){
                func(r[i]);
            }
        },
        intarray: function(array){
            return $.map(array, $u.integ);
        },
        integ: function(str){
            return parseInt(str, 10);
        }
    };
    // Raphael cheat sheet:
    // paper.circle(x,y,radius)
    // paper.rect(x,y,width,height[,corner_radius])
    // paper.ellipse(x,y,h_radius,y_radius)
    // paper.image(src,x,y,width,height)
    // paper.set() // used for grouping elements
    // paper.text(x,y,txt)
    // paper.path(svg_path_string)
    // paper.clear() // clears all elements from canvas
    // element.node() // gives access to DOM object
    // element.remove() 
    // element.hide()
    // element.show()
    // element.rotate(degrees, isAbsolute)
    // element.rotate(degrees, origin_x, origin_y)
    // element.translate(dx, dy)
    // element.scale(xtimes, ytimes, [centerx, centery])
    // element.attr(name,value)
    // element.attr({parameters})
    // element.attr(name) // returns current value
    // element.attr([names]) // array of names, returns array of values
    // element.attr() // returns all names
    // ATTRIBUTES:
    //     clip-rect: comma or space separated x, y, width, height as string
    //     cursor: name of cursor as string
    //     cx: number
    //     cy: number
    //     fill: colour or gradient
    //         linear gradient: "<angle>-<color>[-<color:offset>]-<color>"
    //         radial gradient: "r[(<fx>,<fy>)]<color>[-<color>[:offset]]-<color>"
    //         Focal coordinates are from 0..1
    //         Radial gradients can only be applied to circles and ellipses
    //     fill-opacity: number
    //     font: string
    //     font-family: string
    //     font-size: number
    //     font-weight: string
    //     height: number
    //     href: string (url, turns element into hyperlink)
    //     opacity: number
    //     path: pathString
    //     r: number
    //     rotation: number
    //     rx: number
    //     ry: number
    //     scale: string
    //     src: string (url)
    //     stroke: color
    //     stroke-dasharray: string
    //     stroke-linecap: ["butt", "square", "round"]
    //     stroke-linejoin: ["bevel", "round", "miter"]
    //     stroke-miterlimit: number
    //     stroke-opacity: number
    //     stroke-width: number
    //     target: string (used with href)
    //     text-anchor: ["start", "middle", "end"]
    //     title: string
    //     translation: string
    //     width: number
    //     x: number
    //     y: number
    // element.animate({newattrs}, ms, callback)
    // element.animate({newattrs}, ms, easing, callback)
    // element.animate({keyframes}, ms)
    // ATTRIBUTES THAT CAN BE ANIMATED
    //     clip-rect: string
    //     cx: number
    //     cy: number
    //     fill: color
    //     fill-opacity: number
    //     font-size: number
    //     height: number
    //     opacity: number
    //     path: pathstring
    //     r: number
    //     rotation: string
    //     rx: number
    // element.animateWith([same as animate, but first argument is an element to synchronize with])
    // element.animateAlong(pathobject|pathstring, ms, rotateFlag, callback)
    // element.animateAlongBack(pathobject|pathstring, ms, rotateFlag, callback)
    // element.onAnimation(func)
    // element.getBBox()
    // element.toFront()
    // element.toBack()
    // element.insertBefore(elem)
    // element.insertAfter(elem)
    // element.clone()
    // path.getTotalLength()
    // path.getPointAtLength()
    // path.getSubpath(from_px, to_px)
    // paper.setSize(width, height)
    // Raphael.getRGB(colorstring)
    // Raphael.angle(x1, y1, x2, y2[, x3, y3])
    // Raphael.rad(degrees)
    // Raphael.deg(radians)
    // Raphael.snapTo(values, value[, tolerance])
    // Raphael.getColor()
    // Raphael.getColor.reset()
    // Raphael.registerFont(font)
    // paper.getFont(family[, weight][, style][, stretch])
    // paper.print(x, y, text, font, font_size)
        
    
    // Code goes here
    // var sketch = new Sketch($('.canvas')[0], WIDTH, HEIGHT, true)
    //     .arrow( 150, 150, 200,200)
    //     .arrow( 150,90, 180,65)
    //     .rect(70,90,70,50,'Baz')
    //     .rect(210,180,60,90,'Foo')
    //     .rect(190,40,80,50,'Bar')
    //     .draw();
    $('code').sketch();
    
    // var c;
    // $u.range(100).forEach(function(idx){
    //     c = paper.circle($u.random(WIDTH), $u.random(HEIGHT), $u.random(40,100));
    //     c.attr({fill: Raphael.getColor(), 'fill-opacity': 0.3});
    // });
    </script>
</body>
</html>