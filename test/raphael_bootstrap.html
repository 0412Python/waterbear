<!DOCTYPE HTML>
<html lang="en">
<head>
    <title>Raphael Workshop</title>
    <style>
        @font-face {
        	font-family: 'DadhandRegular';
        	src: url('../lib/dadhand-webfont.eot');
        	src: local('â˜º'), url('../lib/dadhand-webfont.woff') format('woff'), url('../lib/dadhand-webfont.ttf') format('truetype'), url('../lib/dadhand-webfont.svg#webfontiNDkHeiT') format('svg');
        	font-weight: normal;
        	font-style: normal;
        }        
        .wftext{
            fill: #FFFFFF;
			font-weight: normal;
			font-style: normal;
			line-height:normal;
			font-size: 18pt;
            font-family: 'DadhandRegular', Georgia, "New Century Schoolbook", "Nimbus Roman No9 L", serif;
            font-size-adjust: 0.45;
        }
        .wfline{
            stroke: #FFFFFF;
            stoke-width: 2px;
        }
        .nobp .wfline{
            stroke: #333333;
        }
        .nobp .wftext{
            fill: #333333;
        }
    </style>
</head>
<body>
    <pre><code>
        sketch 500 500 true
        crossellipse 30 30 70 40
        crossellipse 300 30 40 40
        arrow 150  150 200 200
        arrow 150 90 180 65
        ellipse 70 90 70 50 Baz
        rect 210 180 60 90 Foo
        rect 190 40 80 50 Bar
        img 250 300 50 80
        fatarrowleft 30 400 80 50
        fatarrowright 390 400 80 50
        options 300 100 140 30
    </code><pre>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/raphael-min.js"></script>
    <script>
    Raphael.fn.line = function(x1,y1, x2,y2){
        var path = new Path()
            .moveto(x1, y1)
            .lineto(x2, y2);
        return this.path(path);
    };
    Raphael.fn.blueprint = function(spacing){
        var background = '#3459B3';
        var self = this;
        var lines = '#4B6DBC';
        if (spacing === undefined){
            spacing = 10;
        }
        this.rect(0,0,WIDTH,HEIGHT).attr('fill', background);
        var lineattrs = {stroke: lines, 'stroke-width': 0.5};
        $u.iterrange(0, WIDTH, spacing, function(x){
            self.line(x, 0, x, HEIGHT).attr(lineattrs);
        });
        $u.iterrange(0, HEIGHT, spacing, function(y){
            self.line(0, y, WIDTH, y).attr(lineattrs);
        });
    }
    jQuery.fn.extend({
        sketch: function(){
            this.each(function(){
                var self = $(this);
                var elem = this;
                var lines = $.trim(self.text()).split('\n');
                if (lines.length && /^sketch/.test(lines[0])){
                    var sketch;
                    $.each(lines, function(idx, line){
                        var words = $.trim(line).split(/\s+/);
                        var cmd = words[0];
                        switch(cmd){
                            case 'sketch':
                                self.text('');
                                var w = $u.integ(words[1]),
                                    h = $u.integ(words[2]),
                                    bp = words.length > 3 && words[3] === 'true';
                                sketch = new Sketch(elem, w, h, bp);
                                break;
                            case 'line':
                            case 'rect':
                            case 'arrow':
                            case 'img':
                            case 'ellipse':
                            case 'crossellipse':
                            case 'fatarrowleft':
                            case 'fatarrowright':
                            case 'options':
                                var args = $u.intarray(words.slice(1,5));
                                args.push(words.slice(5).join(' ')); // text for rect
                                sketch[cmd].apply(sketch, args);
                                break;
                            case 'text':
                                var x = parseInt(words[1], 10),
                                    y = parseInt(words[2], 10),
                                    text = words.slice(3).join(' ');
                                sketch.text(x,y,text);
                                break;
                        }
                        if (sketch){
                            sketch.draw();
                        }
                    });
                }
            });
        }
    });
    var WIDTH = 500,
        HEIGHT = 500,
        paper = Raphael($('.canvas')[0], WIDTH, HEIGHT);
    // Utility methods I usually need
    
    function Path(){
        this._path = [];
    }
    Path.prototype.moveto = function(x, y){
        this._path.push('M' + x + ' ' + y);
        return this;
    };
    Path.prototype.moveby = function(x, y){
        this._path.push('m' + x + ' ' + y);
        return this;
    };
    Path.prototype.lineto = function(x, y){
        this._path.push('L' + x + ' ' + y);
        return this;
    };
    Path.prototype.lineby = function(x, y){
        this._path.push('l' + x + ' ' + y);
        return this;
    };
    Path.prototype.closepath = function(){
        this._path.push('Z');
        return this;
    };
    Path.prototype.horizontalto = function(x){
        this._path.push('H' + x);
        return this;
    };
    Path.prototype.horizontalby = function(x){
        this._path.push('h' + x);
        return this;
    };
    Path.prototype.verticalto = function(y){
        this._path.push('V' + y);
        return this;
    };
    Path.prototype.verticalby = function(y){
        this._path.push('v', + y);
        return this;
    };
    Path.prototype.beziercurveto = function(cx1, cy1, cx2, cy2, x, y){
        this._path.push('C' + [cx1, cy1, cx2, cy2, x, y].map(function(p){return Math.round(p);}).join(' '));
        return this;
    };
    Path.prototype.beziercurveby = function(cx1, cy1, cx2, cy2, x, y){
        this._path.push('c' + [cx1, cy1, cx2, cy2, x, y].join(' '));
        return this;
    };
    // Can add smooth and quadratic beziers and elliptical arcs as needed
    Path.prototype.toString = function(){
        return this._path.join(' ');
    };
    Path.prototype.curve = function(vertArray, tightness){
    // Catmull-Rom curve, approximated with beziers
        if (vertArray.length > 3) {
            var b = [],
                curTightness = tightness || 0,
                s = 1 - curTightness;
            this.moveto(vertArray[1][0], vertArray[1][1]);
             /*
             * Matrix to convert from Catmull-Rom to cubic Bezier
             * where t = curTightness
             * |0         1          0         0       |
             * |(t-1)/6   1          (1-t)/6   0       |
             * |0         (1-t)/6    1         (t-1)/6 |
             * |0         0          0         0       |
             */
             for (var i = 1; (i+2) < vertArray.length; i++) {
                 b[0] = [vertArray[i][0], vertArray[i][1]];
                 b[1] = [vertArray[i][0] + (s * vertArray[i+1][0] - s * vertArray[i-1][0]) / 6,
                    vertArray[i][1] + (s * vertArray[i+1][1] - s * vertArray[i-1][1]) / 6];
                 b[2] = [vertArray[i+1][0] + (s * vertArray[i][0] - s * vertArray[i+2][0]) / 6,
                    vertArray[i+1][1] + (s * vertArray[i][1] - s * vertArray[i+2][1]) / 6];
                 b[3] = [vertArray[i+1][0], vertArray[i+1][1]];
                 this.beziercurveto(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
             }
             return this;
         }
     };
    
    function Sketch(elem, width,height,blueprint){
        this._paper = Raphael(elem, width, height);
        if(blueprint){
            this._paper.blueprint();
        }else{
            $(elem).addClass('nobp');
        }
        this._path = new Path();
    }
    Sketch.prototype.line = function(x1, y1, x2, y2){
        var random = $u.random;
        var dx = (x2 - x1) / 3;
        var dy = (y2 - y1) / 3;
        var splitline = [[x1,y1],[x1,y1],[x1+dx,y1+dy],[x1+dx*2,y1+dy*2],[x2,y2],[x2,y2]];
        var overlines = $u.choice([1,1,1,1,1,1,1,2,2,2,3]);
        for (var i = 0; i < overlines; i++){
            this._path.curve(splitline.map($u.nudge));
            // this._path.curve($.map(splitline, $u.nudge));
        }
        return this;
    };
    Sketch.prototype.rect = function(x, y, w, h, text){
        this.line(x,y,x,y+h);
        this.line(x,y,x+w,y);
        this.line(x+w,y,x+w,y+h);
        this.line(x,y+h,x+w,y+h);
        if (text !== undefined){
            this.text(x+w/2,y+h/2,text);
        }
        return this;
    };
    Sketch.prototype.text = function(x, y, text){
        var t = this._paper.text(x,y,text).node;
        t.removeAttribute('style');
        t.removeAttribute('font');
        t.removeAttribute('fill');
        t.setAttribute('class', 'wftext');
        return this;
    };
    Sketch.prototype.arrow = function(x1,y1,x2,y2){
        var angle = Raphael.angle(x1,y1,x2,y2);
        var x3,y3,x4,y4;
        x3 = $u.dcos(angle + 45) * 10 + x2;
        y3 = $u.dsin(angle + 45) * 10 + y2;
        x4 = $u.dcos(angle - 45) * 10 + x2;
        y4 = $u.dsin(angle - 45) * 10 + y2;
        this.line(x1,y1,x2,y2);
        this.line(x2,y2,x3,y3);
        this.line(x2,y2,x4,y4);
        return this;
    };
    Sketch.prototype.img = function(x,y,w,h){
        this.rect(x,y,w,h);
        this.line(x,y,x+w,y+h);
        this.line(x+w,y,x,y+h);
        return this;
    };
    Sketch.prototype.ellipse = function(x,y,w,h,text){
        var points = $u.ellipse(x,y,w,h, 8);
        var count = $u.random(3, 19);
        $u.range(count).forEach(function(i){
            points.push(points[i % 8]);
        });
        if (text !== undefined){
            this.text(x+w/2,y+h/2,text);
        }
        this._path.curve(points.map($u.nudge));
        return this;
    };
    Sketch.prototype.crossellipse = function(x,y,w,h){
        var points = $u.ellipse(x,y,w,h, 8);
        this.line(points[1][0],points[1][1],points[5][0],points[5][1]);
        this.line(points[3][0],points[3][1],points[7][0],points[7][1]);
        var count = $u.random(3, 19);
        $u.range(count).forEach(function(i){
            points.push(points[i % 8]);
        });
        this._path.curve(points.map($u.nudge));
        return this;
    };
    Sketch.prototype.fatarrowright = function(x,y,w,h,text){
        var dW = w/3, // vertical inset for body of arrow
            dH = h/5,  // horizontal inset for point of arrow
            x2 = x+w-dW, x3=x+w;
            y2 = y+dH, y3 = y+h/2, y4 = y+h-dH, y5 = y+h;
        this.line(x,y2,x2,y2).line(x2,y2,x2,y).line(x2,y,x3,y3)
            .line(x3,y3,x2,y5).line(x2,y5,x2,y4).line(x2,y4,x,y4)
            .line(x,y4,x,y2);
        return this;
    };
    Sketch.prototype.fatarrowleft = function(x,y,w,h,text){
        x=x+w; // draw from right to left
        var dW = w/3, // vertical inset for body of arrow
            dH = h/5,  // horizontal inset for point of arrow
            x2 = x-w+dW, x3=x-w;
            y2 = y+dH, y3 = y+h/2, y4 = y+h-dH, y5 = y+h;
        this.line(x,y2,x2,y2).line(x2,y2,x2,y).line(x2,y,x3,y3)
            .line(x3,y3,x2,y5).line(x2,y5,x2,y4).line(x2,y4,x,y4)
            .line(x,y4,x,y2);
        return this;
    };
    Sketch.prototype.triangledown = function(x,y,w,h){
        return this.line(x,y,x+w,y).line(x+w,y,x+w/2,y+h).line(x+w/2,y+h,x,y);
    };
    Sketch.prototype.options = function(x,y,w,h,text){
        if (!text.length){
            text = 'options';
        }
        this.rect(x,y,w-h,h,text);
        this.rect(x+w-h,y,h,h);
        var off=8;
        this.triangledown(x+w-h+off,y+off,h-off*2,h-off*2);
        return this;
    }
    Sketch.prototype.draw = function(){
        var n = this._paper.path(this._path).node;
        n.removeAttribute('stroke');
        n.setAttribute('class', 'wfline');
        return this;
    };

    var $u = {
        removeItem: function(list, item){
            list.splice(list.indexOf(item), 1);
        },
        dcos: function(degrees){
            return Math.cos(Raphael.rad(degrees));
        },
        dsin: function(degrees){
            return Math.sin(Raphael.rad(degrees));
        },
        random: function(a,b){
            // 'Returns an integer between a and b, inclusive';
            // 'If b is not specified, returns an integer between 0 and a';
            if (b === undefined){
                b = a;
                a = 0;
            }
            return Math.floor(Math.random() * (b-a + 1)) + a;
        },
        choice: function(list){
            // This is an exclusive, or mutating choice that
            // picks a random item from a list and removes that
            // item before returning it
            var idx = $u.random(0, list.length - 1);
            var item = list[idx];
            list.splice(idx, 1); // remove item from list
            return item;
        },
        range: function(start, stop, step){
            // similar to Python's range function
            // should be extended to handle negative steps
            if (stop === undefined){
                stop = start;
                start = 0;
            }
            if (step === undefined){
                step = 1;
            }
            var r = [], i;
            for(i = start; i < stop; i += step){
                r.push(i);
            }
            return r;
        },
        iterrange: function(start, stop, step, func){
            var r = $u.range(start, stop, step);
            for (var i in r){
                func(r[i]);
            }
        },
        intarray: function(array){
            return $.map(array, $u.integ);
        },
        integ: function(str){
            return parseInt(str, 10);
        },
        nudge: function(pt){
            return [pt[0] + $u.random(-2,2), pt[1] + $u.random(-2, 2)];
        },
        ellipse: function(x,y,w,h,steps){
        /*
        * This functions returns an array containing points to draw an
        * ellipse in the rect defined by x,y,w,h
        */
            w = w/2;
            h = h/2;
            x = x + w;
            y = y + h;
            if (steps === undefined){
                steps = 36;
            }
            var points = [];
            var a = w, // semi-major axis
                b = h, // semi-minor axis
                beta = 0;
            if (w > h){
                a = h;
                b = w;
                beta = -Math.PI / 2;
            } 
            var sinbeta = Math.sin(beta);
            var cosbeta = Math.cos(beta);
            var i, alpha, sinalpha, cosalpha,X,Y;
            for (i = 0; i < 360; i += 360 / steps) {
                alpha = i * (Math.PI / 180) ;
                sinalpha = Math.sin(alpha);
                cosalpha = Math.cos(alpha);
                X = x + (a * cosalpha * cosbeta - b * sinalpha * sinbeta);
                Y = y + (a * cosalpha * sinbeta + b * sinalpha * cosbeta);

                points.push([X,Y]);
            }
            return points;
            }
    };
    // Raphael cheat sheet:
    // paper.circle(x,y,radius)
    // paper.rect(x,y,width,height[,corner_radius])
    // paper.ellipse(x,y,h_radius,y_radius)
    // paper.image(src,x,y,width,height)
    // paper.set() // used for grouping elements
    // paper.text(x,y,txt)
    // paper.path(svg_path_string)
    // paper.clear() // clears all elements from canvas
    // element.node() // gives access to DOM object
    // element.remove() 
    // element.hide()
    // element.show()
    // element.rotate(degrees, isAbsolute)
    // element.rotate(degrees, origin_x, origin_y)
    // element.translate(dx, dy)
    // element.scale(xtimes, ytimes, [centerx, centery])
    // element.attr(name,value)
    // element.attr({parameters})
    // element.attr(name) // returns current value
    // element.attr([names]) // array of names, returns array of values
    // element.attr() // returns all names
    // ATTRIBUTES:
    //     clip-rect: comma or space separated x, y, width, height as string
    //     cursor: name of cursor as string
    //     cx: number
    //     cy: number
    //     fill: colour or gradient
    //         linear gradient: "<angle>-<color>[-<color:offset>]-<color>"
    //         radial gradient: "r[(<fx>,<fy>)]<color>[-<color>[:offset]]-<color>"
    //         Focal coordinates are from 0..1
    //         Radial gradients can only be applied to circles and ellipses
    //     fill-opacity: number
    //     font: string
    //     font-family: string
    //     font-size: number
    //     font-weight: string
    //     height: number
    //     href: string (url, turns element into hyperlink)
    //     opacity: number
    //     path: pathString
    //     r: number
    //     rotation: number
    //     rx: number
    //     ry: number
    //     scale: string
    //     src: string (url)
    //     stroke: color
    //     stroke-dasharray: string
    //     stroke-linecap: ["butt", "square", "round"]
    //     stroke-linejoin: ["bevel", "round", "miter"]
    //     stroke-miterlimit: number
    //     stroke-opacity: number
    //     stroke-width: number
    //     target: string (used with href)
    //     text-anchor: ["start", "middle", "end"]
    //     title: string
    //     translation: string
    //     width: number
    //     x: number
    //     y: number
    // element.animate({newattrs}, ms, callback)
    // element.animate({newattrs}, ms, easing, callback)
    // element.animate({keyframes}, ms)
    // ATTRIBUTES THAT CAN BE ANIMATED
    //     clip-rect: string
    //     cx: number
    //     cy: number
    //     fill: color
    //     fill-opacity: number
    //     font-size: number
    //     height: number
    //     opacity: number
    //     path: pathstring
    //     r: number
    //     rotation: string
    //     rx: number
    // element.animateWith([same as animate, but first argument is an element to synchronize with])
    // element.animateAlong(pathobject|pathstring, ms, rotateFlag, callback)
    // element.animateAlongBack(pathobject|pathstring, ms, rotateFlag, callback)
    // element.onAnimation(func)
    // element.getBBox()
    // element.toFront()
    // element.toBack()
    // element.insertBefore(elem)
    // element.insertAfter(elem)
    // element.clone()
    // path.getTotalLength()
    // path.getPointAtLength()
    // path.getSubpath(from_px, to_px)
    // paper.setSize(width, height)
    // Raphael.getRGB(colorstring)
    // Raphael.angle(x1, y1, x2, y2[, x3, y3])
    // Raphael.rad(degrees)
    // Raphael.deg(radians)
    // Raphael.snapTo(values, value[, tolerance])
    // Raphael.getColor()
    // Raphael.getColor.reset()
    // Raphael.registerFont(font)
    // paper.getFont(family[, weight][, style][, stretch])
    // paper.print(x, y, text, font, font_size)
        
    
    // Code goes here
    // var sketch = new Sketch($('.canvas')[0], WIDTH, HEIGHT, true)
    //     .arrow( 150, 150, 200,200)
    //     .arrow( 150,90, 180,65)
    //     .rect(70,90,70,50,'Baz')
    //     .rect(210,180,60,90,'Foo')
    //     .rect(190,40,80,50,'Bar')
    //     .draw();
    $('code').sketch();
    
    // var c;
    // $u.range(100).forEach(function(idx){
    //     c = paper.circle($u.random(WIDTH), $u.random(HEIGHT), $u.random(40,100));
    //     c.attr({fill: Raphael.getColor(), 'fill-opacity': 0.3});
    // });
    </script>
</body>
</html>