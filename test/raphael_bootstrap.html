<!DOCTYPE HTML>
<html lang="en">
<head>
    <title>Raphael Workshop</title>
    <style>
        @font-face {
        	font-family: 'DadhandRegular';
        	src: url('../lib/dadhand-webfont.eot');
        	src: local('â˜º'), url('../lib/dadhand-webfont.woff') format('woff'), url('../lib/dadhand-webfont.ttf') format('truetype'), url('../lib/dadhand-webfont.svg#webfontiNDkHeiT') format('svg');
        	font-weight: normal;
        	font-style: normal;
        }        
        .wftext{
			font-weight: normal;
			font-style: normal;
			line-height:normal;
			font-size: 18pt;
            font-family: 'DadhandRegular', Georgia, "New Century Schoolbook", "Nimbus Roman No9 L", serif;
            font-size-adjust: 0.45;
        }
        .canvas{
            width: 500px;
            height: 500px;
        }
    </style>
</head>
<body>
    <div class="canvas"></div>
    <script src="../lib/jquery.min.js"></script>
    <script src="../lib/raphael-min.js"></script>
    <script>
    Raphael.fn.line = function(x1,y1, x2,y2){
        var path = new Path()
            .moveto(x1, y1)
            .lineto(x2, y2);
        return paper.path(path);
    };
    jQuery.fn.extend({
        sketch: function(){
            this.each(function(elem){
                var self = $(elem);
                var lines = self.text().split('\n');
                if (lines.length && /^sketch/.test(lines[0])){
                    $.each(lines, function(line){
                        var x,y,x1,y1,x2,y2,h,w,text,angle;
                        var words = line.split(/\s+/);
                        var cmd = words[0];
                        var sketch;
                        switch(cmd){
                            case 'sketch':
                                elem.innerText = '';
                                w = parseInt(word[1], 10);
                                h = parseInt(word[2], 10);
                                sketch = new Sketch(elem, w, h);
                                break;
                            case 'line':
                                x1 = parseInt(word[1], 10);
                                y1 = parseInt(word[2], 10);
                                x2 = parseInt(word[3], 10);
                                y2 = parseInt(word[4], 10);
                                sketch.line(x1, y1, x2, y2);
                                break;
                            case 'rect':
                                x = parseInt(word[1], 10);
                                y = parseInt(word[2], 10);
                                w = parseInt(word[3], 10);
                                h = parseInt(word[4], 10);
                                text = word.slice(5).join(' ');
                                sketch.rect(x,y,w,h,text);
                                break;
                            case 'text':
                                x = parseInt(word[1], 10);
                                y = parseInt(word[2], 10);
                                text = word.slice(3).join(' ');
                                sketch.text(x,y,text);
                                break;
                            case 'arrow':
                                x1 = parseInt(word[1], 10);
                                y1 = parseInt(word[2], 10);
                                x2 = parseInt(word[3], 10);
                                x3 = parseInt(word[4], 10);
                                angle = Raphael.angle(x1, y1, x2, y2);
                                break;
                        }
                    });
                }
            });
        }
    });
    var WIDTH = 500,
        HEIGHT = 500,
        paper = Raphael($('.canvas')[0], WIDTH, HEIGHT);
    // Utility methods I usually need
    
    function Path(){
        this._path = [];
    }
    Path.prototype.moveto = function(x, y){
        this._path.push('M' + x + ' ' + y);
        return this;
    };
    Path.prototype.moveby = function(x, y){
        this._path.push('m' + x + ' ' + y);
        return this;
    };
    Path.prototype.lineto = function(x, y){
        this._path.push('L' + x + ' ' + y);
        return this;
    };
    Path.prototype.lineby = function(x, y){
        this._path.push('l' + x + ' ' + y);
        return this;
    };
    Path.prototype.closepath = function(){
        this._path.push('Z');
        return this;
    };
    Path.prototype.horizontalto = function(x){
        this._path.push('H' + x);
        return this;
    };
    Path.prototype.horizontalby = function(x){
        this._path.push('h' + x);
        return this;
    };
    Path.prototype.verticalto = function(y){
        this._path.push('V' + y);
        return this;
    };
    Path.prototype.verticalby = function(y){
        this._path.push('v', + y);
        return this;
    };
    Path.prototype.beziercurveto = function(cx1, cy1, cx2, cy2, x, y){
        this._path.push('C' + [cx1, cy1, cx2, cy2, x, y].map(function(p){return Math.round(p);}).join(' '));
        return this;
    };
    Path.prototype.beziercurveby = function(cx1, cy1, cx2, cy2, x, y){
        this._path.push('c' + [cx1, cy1, cx2, cy2, x, y].join(' '));
        return this;
    };
    // Can add smooth and quadratic beziers and elliptical arcs as needed
    Path.prototype.toString = function(){
        return this._path.join(' ');
    };
    Path.prototype.curve = function(vertArray, tightness){
    // Catmull-Rom curve, approximated with beziers
        if (vertArray.length > 3) {
            var b = [],
                curTightness = tightness || 0,
                s = 1 - curTightness;
            this.moveto(vertArray[1][0], vertArray[1][1]);
             /*
             * Matrix to convert from Catmull-Rom to cubic Bezier
             * where t = curTightness
             * |0         1          0         0       |
             * |(t-1)/6   1          (1-t)/6   0       |
             * |0         (1-t)/6    1         (t-1)/6 |
             * |0         0          0         0       |
             */
             for (var i = 1; (i+2) < vertArray.length; i++) {
                 b[0] = [vertArray[i][0], vertArray[i][1]];
                 b[1] = [vertArray[i][0] + (s * vertArray[i+1][0] - s * vertArray[i-1][0]) / 6,
                    vertArray[i][1] + (s * vertArray[i+1][1] - s * vertArray[i-1][1]) / 6];
                 b[2] = [vertArray[i+1][0] + (s * vertArray[i][0] - s * vertArray[i+2][0]) / 6,
                    vertArray[i+1][1] + (s * vertArray[i][1] - s * vertArray[i+2][1]) / 6];
                 b[3] = [vertArray[i+1][0], vertArray[i+1][1]];
                 this.beziercurveto(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
             }
             return this;
         }
     };
    Path.prototype.sketchline = function(x1, y1, x2, y2){
        var random = $u.random;
        var overlines = $u.choice([1,1,1,1,1,1,1,2,2,2,3]);
        for (var i = 0; i < overlines; i++){
            this.curve([[ x1 + random(-2,2), y1 +random(-2,2)],
                      [ x1 + random(-2,2), y1 +random(-2,2)],
                      [ x1+(x2 -x1)/3 + random(-2,2), y1 + (y2-y1)/3 +random(-2,2)],
                      [ x1+2*(x2-x1)/3 + random(-2,2), y1+ 2*(y2-y1)/3 +random(-2,2)], 
                      [ x2 + random(-2,2), y2 +random(-2,2)],
                      [ x2 + random(-2,2), y2 +random(-2,2)]]);
        }
        return this;
    };
    Path.prototype.sketchrect = function(x, y, w, h, text){
        this.sketchline(x,y,x,y+h);
        this.sketchline(x,y,x+w,y);
        this.sketchline(x+w,y,x+w,y+h);
        this.sketchline(x,y+h,x+w,y+h);
        if (text !== undefined){
            var t = paper.text(x+w/2,y+h/2,text).node;
            t.removeAttribute('style');
            t.removeAttribute('font');
            t.setAttribute('class', 'wftext');
        }
        return this;
    };
    
    function Sketch(elem, width,height){
        this._paper = Raphael(elem, width, height);
        this._path = new Path();
    }


    var $u = {
        removeItem: function(list, item){
            list.splice(list.indexOf(item), 1);
        },
        random: function(a,b){
            // 'Returns an integer between a and b, inclusive';
            // 'If b is not specified, returns an integer between 0 and a';
            if (b === undefined){
                b = a;
                a = 0;
            }
            return Math.floor(Math.random() * (b-a + 1)) + a;
        },
        choice: function(list){
            // This is an exclusive, or mutating choice that
            // picks a random item from a list and removes that
            // item before returning it
            var idx = $u.random(0, list.length - 1);
            var item = list[idx];
            list.splice(idx, 1); // remove item from list
            return item;
        },
        range: function(start, stop, step){
            // similar to Python's range function
            // should be extended to handle negative steps
            if (stop === undefined){
                stop = start;
                start = 0;
            }
            if (step === undefined){
                step = 1;
            }
            var r = [], i;
            for(i = start; i < stop; i += step){
                r.push(i);
            }
            return r;
        },
        iterrange: function(start, stop, step, func){
            var r = $u.range(start, stop, step);
            for (var i in r){
                func(r[i]);
            }
        },
        blueprint: function(spacing){
            var background = '#3459B3';
            var lines = '#4B6DBC';
            if (spacing === undefined){
                spacing = 10;
            }
            paper.rect(0,0,WIDTH,HEIGHT).attr('fill', background);
            var lineattrs = {stroke: lines, 'stroke-width': 0.5};
            $u.iterrange(0, WIDTH, spacing, function(x){
                paper.line(x, 0, x, HEIGHT).attr(lineattrs);
            });
            $u.iterrange(0, HEIGHT, spacing, function(y){
                paper.line(0, y, WIDTH, y).attr(lineattrs);
            });
        }
    };
    // Raphael cheat sheet:
    // paper.circle(x,y,radius)
    // paper.rect(x,y,width,height[,corner_radius])
    // paper.ellipse(x,y,h_radius,y_radius)
    // paper.image(src,x,y,width,height)
    // paper.set() // used for grouping elements
    // paper.text(x,y,txt)
    // paper.path(svg_path_string)
    // paper.clear() // clears all elements from canvas
    // element.node() // gives access to DOM object
    // element.remove() 
    // element.hide()
    // element.show()
    // element.rotate(degrees, isAbsolute)
    // element.rotate(degrees, origin_x, origin_y)
    // element.translate(dx, dy)
    // element.scale(xtimes, ytimes, [centerx, centery])
    // element.attr(name,value)
    // element.attr({parameters})
    // element.attr(name) // returns current value
    // element.attr([names]) // array of names, returns array of values
    // element.attr() // returns all names
    // ATTRIBUTES:
    //     clip-rect: comma or space separated x, y, width, height as string
    //     cursor: name of cursor as string
    //     cx: number
    //     cy: number
    //     fill: colour or gradient
    //         linear gradient: "<angle>-<color>[-<color:offset>]-<color>"
    //         radial gradient: "r[(<fx>,<fy>)]<color>[-<color>[:offset]]-<color>"
    //         Focal coordinates are from 0..1
    //         Radial gradients can only be applied to circles and ellipses
    //     fill-opacity: number
    //     font: string
    //     font-family: string
    //     font-size: number
    //     font-weight: string
    //     height: number
    //     href: string (url, turns element into hyperlink)
    //     opacity: number
    //     path: pathString
    //     r: number
    //     rotation: number
    //     rx: number
    //     ry: number
    //     scale: string
    //     src: string (url)
    //     stroke: color
    //     stroke-dasharray: string
    //     stroke-linecap: ["butt", "square", "round"]
    //     stroke-linejoin: ["bevel", "round", "miter"]
    //     stroke-miterlimit: number
    //     stroke-opacity: number
    //     stroke-width: number
    //     target: string (used with href)
    //     text-anchor: ["start", "middle", "end"]
    //     title: string
    //     translation: string
    //     width: number
    //     x: number
    //     y: number
    // element.animate({newattrs}, ms, callback)
    // element.animate({newattrs}, ms, easing, callback)
    // element.animate({keyframes}, ms)
    // ATTRIBUTES THAT CAN BE ANIMATED
    //     clip-rect: string
    //     cx: number
    //     cy: number
    //     fill: color
    //     fill-opacity: number
    //     font-size: number
    //     height: number
    //     opacity: number
    //     path: pathstring
    //     r: number
    //     rotation: string
    //     rx: number
    // element.animateWith([same as animate, but first argument is an element to synchronize with])
    // element.animateAlong(pathobject|pathstring, ms, rotateFlag, callback)
    // element.animateAlongBack(pathobject|pathstring, ms, rotateFlag, callback)
    // element.onAnimation(func)
    // element.getBBox()
    // element.toFront()
    // element.toBack()
    // element.insertBefore(elem)
    // element.insertAfter(elem)
    // element.clone()
    // path.getTotalLength()
    // path.getPointAtLength()
    // path.getSubpath(from_px, to_px)
    // paper.setSize(width, height)
    // Raphael.getRGB(colorstring)
    // Raphael.angle(x1, y1, x2, y2[, x3, y3])
    // Raphael.rad(degrees)
    // Raphael.deg(radians)
    // Raphael.snapTo(values, value[, tolerance])
    // Raphael.getColor()
    // Raphael.getColor.reset()
    // Raphael.registerFont(font)
    // paper.getFont(family[, weight][, style][, stretch])
    // paper.print(x, y, text, font, font_size)
        
    
    // Code goes here
    $u.blueprint();
    var lineattr = {stroke: '#FFFFFF', 'stroke-width': 2};
    
    var arrow1 = paper.path(new Path()
        .sketchline( 150, 150, 200,200)
        .sketchline( 180,200,200,200)
        .sketchline( 200,180, 200, 200)).attr(lineattr);

    var arrow2 = paper.path(new Path()
        .sketchline( 150,90, 180,65)
        .sketchline( 180,75, 180,65)
        .sketchline( 170,65, 180,65)).attr(lineattr);
    
    var bazBox = paper.path(new Path().sketchrect(70,90,70,50,'Baz')).attr(lineattr);
    var fooBox = paper.path(new Path().sketchrect(210,180,60,90,'Foo')).attr(lineattr);
    var barBox = paper.path(new Path().sketchrect(190,40,80,50,'Bar')).attr(lineattr);
    
    // var c;
    // $u.range(100).forEach(function(idx){
    //     c = paper.circle($u.random(WIDTH), $u.random(HEIGHT), $u.random(40,100));
    //     c.attr({fill: Raphael.getColor(), 'fill-opacity': 0.3});
    // });
    </script>
</body>
</html>